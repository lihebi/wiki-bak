<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf8">
    <title>coding/shell.md 正文 - 白衣染霜华</title>
    <link rel="stylesheet" href="/css/adc39f9c.app.css">
    <link href="/css/06f85b78.main.css" rel="stylesheet">
  </head>
  <body>
    <div class="narrow"><h1 id="-">变量</h1>
<p>&quot;&quot;中的变量$xxx会解析,&#39;&#39;不会.</p>
<pre><code>`xxx` &lt;=&gt; $(xxx)
</code></pre><h2 id="-">变量替换</h2>
<p><strong>返回结果，但不改变原变量的值。</strong></p>
<pre><code># 若var未被声明，则以DEFAULT为其值
${var-DEFAULT}
${var=DEFAULT}
# 若
# 1. var 未被声明 或
# 2. 其值为空
# 则以DEFAULT为其值
${var:-DEFAULT}
${var:=DEFAULT}
</code></pre><h2 id="-">特殊变量</h2>
<pre><code>$0 # 脚本名称
$&lt;n&gt; # 第n个参数
$# # 参数数量
$* # 所有参数，作为一个字符串
$@ # 所有参数，作为字符串数组
</code></pre><pre><code># example

./a.sh hello world
&quot;$0&quot; =&gt; ./a.sh
&quot;$1&quot; =&gt; hello
&quot;$2&quot; =&gt; world
&quot;$#&quot; =&gt; 2
&quot;$*&quot; =&gt; &quot;./a.sh hello world&quot;
&quot;$@&quot; =&gt; [ &quot;./a.sh&quot; &quot;hello&quot; &quot;world&quot; ]
</code></pre><pre><code>$$ # 当前进程的PID
$? # 上一个命令的返回值
$! # 运行在后台的最后一个进程的PID。done了也算。
$_ # 上个命令的最后一个字段
</code></pre><h1 id="-">字符串</h1>
<p>substring使用的是bash中的正则。</p>
<ul>
<li><code>${#string}</code> $string的长度</li>
<li><code>${string:5}</code> $string 从5位置开始的子串</li>
<li><code>${string:5:3}</code> 5位置开始，提取3个。</li>
<li><code>${string#substring}</code> 从<em>开头</em>删除substring的<em>最短</em>匹配</li>
<li><code>${string##substring}</code> 从<em>开头</em>删除substring的<em>最长</em>匹配</li>
<li><code>${string%substring}</code> 从<em>结尾</em>删除substring的<em>最短</em>匹配</li>
<li><p><code>${string%%substring}</code> 从<em>结尾</em>删除substring的<em>最长</em>匹配</p>
</li>
<li><p><code>${string/substring/replace}</code> 第一个匹配的substring替换为replace</p>
</li>
<li><code>${string/#substring/replace}</code> 开头是substring,则换为replace</li>
<li><code>${string/%substring/replace}</code> 结尾时substring,则换为replace</li>
</ul>
<p>substring若不加引号,则为正常字符串,加引号则可用$转义.</p>
<h1 id="-">用户交互</h1>
<pre><code>read -p &quot;please input: &quot; a b c
</code></pre><h1 id="-">条件测试</h1>
<pre><code>test &lt;exp&gt;
[ &lt;exp&gt; ]
[[ &lt;exp&gt; ]]
</code></pre><h2 id="-">文件测试</h2>
<ul>
<li><code>-e &lt;file&gt;</code> 存在</li>
<li><code>-a &lt;file&gt;</code> 更好的存在.(有时候-e会出错)</li>
<li><code>-f &lt;file&gt;</code> 普通文件?</li>
<li><code>-d &lt;file&gt;</code> 目录?</li>
<li><code>-L &lt;file&gt;</code> 符号链接?</li>
<li><code>-s &lt;file&gt;</code> 非空?(size!=0)</li>
<li><code>-r &lt;file&gt;</code> 可读?</li>
<li><code>-w &lt;file&gt;</code> 可写?</li>
<li><code>-x &lt;file&gt;</code> 可执行?</li>
<li><code>&lt;file1&gt; -nt &lt;file2&gt;</code> newer than?</li>
<li><code>&lt;file1&gt; -ot &lt;file2&gt;</code> older than?</li>
</ul>
<h2 id="-">字符串测试</h2>
<ul>
<li><code>-z &lt;string&gt;</code> 空?</li>
<li><code>-n &lt;string&gt;</code> 非空?</li>
<li><code>string1</code> == <code>string2</code> 相等? 也可直接用=</li>
<li><code>string1</code> != <code>string2</code></li>
</ul>
<h2 id="-">整数</h2>
<p>[]</p>
<ul>
<li><code>-eq</code></li>
<li><code>-ne</code></li>
<li><code>-gt</code></li>
<li><code>-ge</code></li>
<li><code>-lt</code></li>
<li><code>-le</code></li>
</ul>
<p>(())</p>
<ul>
<li>==</li>
<li>!=</li>
<li>&gt;</li>
<li><blockquote>
<p>=</p>
</blockquote>
</li>
<li>&lt;</li>
<li>&lt;=</li>
</ul>
<h2 id="-">逻辑</h2>
<p>[]</p>
<ul>
<li>-a</li>
<li>-o</li>
<li>!</li>
</ul>
<p>[[]]</p>
<ul>
<li>&amp;&amp;</li>
<li>||</li>
<li>!</li>
</ul>
<h1 id="-">数值计算</h1>
<pre><code>(( a=2+3 ))
a = $(( 2+3 ))

a = ((12))
echo $((a++)) # =&gt; 12
echo $((++a)) # =&gt; 14

echo ((5&gt;3)) # =&gt; 1
</code></pre><h1 id="-">语法结构</h1>
<h2 id="if">If</h2>
<pre><code>if condition1; then
  # ...
elif condition2
then
  # ...
else
  # ...
fi
</code></pre><p>其中condition有三种形式：</p>
<p><code>[]</code>: TODO</p>
<p><code>[[]]</code>: TODO</p>
<p><code>(())</code>: TODO</p>
<p>关于<code>;</code>:<br>如果语句后面是行结束符，不需要。<br>如果有<code>then</code>等在一行上，需要。</p>
<h2 id="case">Case</h2>
<pre><code>case $a in
1|en) echo &#39;en&#39;;;
2|zh) echo &#39;zh&#39;;;
esac
</code></pre><h2 id="-">循环</h2>
<pre><code># while
while condition; do xxx; done
# until
until condition; do xxx; done
# for
for condition; do xxx; done
# conditions
for fname in *
for fname in `/etc/*` # do not need the 2 `
for x in aa bb cc
for x in $@
for x; do xx
for (( i=1; i&lt;5; i++ ))
</code></pre><p>可以使用<code>break</code>, <code>continue</code>.</p>
<h2 id="-">函数</h2>
<pre><code># 形式1
function func {
  return 1;
  exit 1;
}
# 形式2
func() {
  return 1;
}
</code></pre><h1 id="-">一些脚本</h1>
<h2 id="ffmpeg-">ffmpeg 连接文件</h2>
<p>Create a file mylist.txt with all the files you want to have concatenated in the following form (lines starting with a # are ignored):</p>
<pre><code># this is a comment
file &#39;/path/to/file1&#39;
file &#39;/path/to/file2&#39;
file &#39;/path/to/file3&#39;
</code></pre><p>then</p>
<pre><code>ffmpeg -f concat -i mylist.txt -c copy output
</code></pre><p>generate mylist.txt</p>
<pre><code>for f in ./*.wav; do echo &quot;file &#39;$f&#39;&quot; &gt;&gt; mylist.txt; done
</code></pre><p>官方文档：<a href="https://trac.ffmpeg.org/wiki/How%20to%20concatenate%20(join,%20merge)%20media%20files)">concat</a></p>
<pre><code class="lang-sh">#!/bin/bash

mkdir out
echo -n &quot;concat:&quot; &gt; out/list.txt
for f in *.mp4
do
    ffmpeg -i $f -c copy -bsf:v h264_mp4toannexb -f mpegts &#39;out/&#39;$f&#39;.ts&#39;
    echo -n $f&#39;.ts|&#39; &gt;&gt; out/list.txt
done

cd out
ffmpeg -i `cat list.txt` -c copy -bsf:a aac_adtstoasc output.mp4
</code></pre>
</div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      
      ga('create', 'UA-50872903-2', 'auto');
      ga('send', 'pageview');
      
    </script>
    <script src="/js/f013a3a9.app.js"></script>
  </body>
</html>